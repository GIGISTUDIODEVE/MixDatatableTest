<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>XP Curve 수식 관리 & 테스트 (Firestore)</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      background: #0f172a;
      color: #e2e8f0;
    }

    .top-nav {
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.9rem 1.5rem;
      margin: -1.5rem -1.5rem 1.25rem;
      background: rgba(11, 18, 32, 0.8);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid #1f2937;
    }

    .nav-brand {
      font-weight: 800;
      letter-spacing: -0.01em;
    }

    .nav-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .nav-link {
      color: #cbd5e1;
      text-decoration: none;
      padding: 0.45rem 0.8rem;
      border-radius: 10px;
      border: 1px solid transparent;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .nav-link:hover {
      background: #111827;
      border-color: #1f2937;
      color: #e2e8f0;
    }

    .nav-link.active {
      background: linear-gradient(90deg, #3b82f6, #06b6d4);
      color: #0b1220;
      border-color: transparent;
    }

    h1 {
      margin-top: 0;
    }

    .container {
      display: grid;
      gap: 1.5rem;
    }

    .card {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .card h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.75rem 1rem;
    }

    label {
      display: block;
      font-weight: 700;
      margin-bottom: 0.35rem;
    }

    input[type="text"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 0.55rem 0.65rem;
      border-radius: 10px;
      border: 1px solid #334155;
      background: #0b1220;
      color: #e2e8f0;
      font-family: inherit;
    }

    textarea {
      min-height: 180px;
      resize: vertical;
      line-height: 1.4;
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 0.6rem 1rem;
      font-weight: 800;
      cursor: pointer;
      transition: transform 0.1s ease, filter 0.15s ease;
    }

    button.primary {
      background: linear-gradient(90deg, #3b82f6, #06b6d4);
      color: #0b1220;
    }

    button.secondary {
      background: #1f2937;
      color: #e2e8f0;
      border: 1px solid #334155;
    }

    button.danger {
      background: #ef4444;
      color: #0b1220;
    }

    button:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }

    th, td {
      border-bottom: 1px solid #1f2937;
      padding: 0.6rem;
      text-align: left;
    }

    th {
      color: #cbd5e1;
      font-size: 0.95rem;
    }

    tr:hover td {
      background: #0b1220;
    }

    .status {
      margin-top: 0.75rem;
      padding: 0.6rem 0.8rem;
      border-radius: 10px;
      background: #0b1220;
      border: 1px solid #1f2937;
      color: #cbd5e1;
      min-height: 1.4rem;
      white-space: pre-line;
    }

    .muted {
      color: #94a3b8;
      font-size: 0.9rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: #1f2937;
      color: #cbd5e1;
      font-size: 0.85rem;
    }

    .result-table {
      max-height: 360px;
      overflow: auto;
      border: 1px solid #1f2937;
      border-radius: 10px;
      margin-top: 0.75rem;
    }
  </style>
</head>
<body>
  <nav class="top-nav">
    <div class="nav-brand">Curve & Stat 관리 도구</div>
    <div class="nav-links">
      <a class="nav-link" href="base-stats-firestore.html">BaseStat 프리셋</a>
      <a class="nav-link" href="growth-base-stats-firestore.html">GrowthBaseStat 프리셋</a>
      <a class="nav-link" href="combat-stats-firestore.html">CombatStats 관리</a>
      <a class="nav-link" href="combat-dps-tester.html">Combat DPS 테스트</a>
      <a class="nav-link active" href="xp-curve-firestore.html">XP Curve 관리</a>
    </div>
  </nav>

  <div class="container">
    <header class="card">
      <h1>XP Curve 수식 관리 & 테스트</h1>
      <p class="muted">XP_Curve_Formula_Recommendations.md 내용을 Firestore에 보관/버전 관리하고, 다양한 수식을 직접 테스트합니다.</p>
    </header>

    <section class="card">
      <h2>문서 관리</h2>
      <div class="grid">
        <div>
          <label for="doc-id">문서 ID (collection: xpCurveDocs)</label>
          <input id="doc-id" type="text" placeholder="xp_curve_formula_recommendations" />
        </div>
        <div>
          <label for="doc-title">제목</label>
          <input id="doc-title" type="text" placeholder="XP Curve 수식 추천" />
        </div>
        <div>
          <label for="doc-tags">태그 (쉼표 구분)</label>
          <input id="doc-tags" type="text" placeholder="power, piecewise, exponential" />
        </div>
      </div>
      <div style="margin-top: 0.75rem;">
        <label for="doc-desc">설명</label>
        <textarea id="doc-desc" placeholder="운영 정책, 반올림 규칙, 추천 파라미터 등을 포함"></textarea>
      </div>
      <div style="margin-top: 0.75rem;">
        <label for="doc-content">본문 (Markdown)</label>
        <textarea id="doc-content" rows="16" placeholder="XP_Curve_Formula_Recommendations.md 내용을 붙여넣으세요"></textarea>
      </div>
      <div class="actions">
        <button class="secondary" id="load-local">로컬 문서 불러오기</button>
        <button class="primary" id="save-doc">Firestore 저장/업데이트</button>
        <button class="secondary" id="reset-doc">입력 초기화</button>
      </div>
      <div class="status" id="doc-status"></div>
    </section>

    <section class="card">
      <h2>저장된 문서</h2>
      <div class="muted">Firestore collection: <code>xpCurveDocs</code></div>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>제목</th>
            <th>태그</th>
            <th>업데이트</th>
            <th>작업</th>
          </tr>
        </thead>
        <tbody id="doc-table-body"></tbody>
      </table>
    </section>

    <section class="card">
      <h2>수식 테스트</h2>
      <div class="grid">
        <div>
          <label for="formula-type">수식 타입</label>
          <select id="formula-type">
            <option value="POWER">POWER</option>
            <option value="PIECEWISE">PIECEWISE</option>
            <option value="EXPONENTIAL">EXPONENTIAL</option>
            <option value="LINEAR">LINEAR</option>
            <option value="LOGISTIC">LOGISTIC</option>
            <option value="TABLE">TABLE</option>
          </select>
        </div>
        <div>
          <label for="rounding">반올림 규칙</label>
          <select id="rounding">
            <option value="CEIL">CEIL</option>
            <option value="ROUND">ROUND</option>
            <option value="FLOOR">FLOOR</option>
          </select>
        </div>
        <div>
          <label for="level-start">레벨 시작</label>
          <input id="level-start" type="number" min="1" value="1" />
        </div>
        <div>
          <label for="level-end">레벨 끝</label>
          <input id="level-end" type="number" min="1" value="20" />
        </div>
      </div>

      <div style="margin-top: 0.75rem;">
        <label for="extra-xp">특정 레벨 추가 XP (JSON 또는 쉼표 구분)</label>
        <textarea
          id="extra-xp"
          rows="3"
          placeholder='{"5": 200, "10": 500} 또는 5:200, 10:500'
        ></textarea>
        <p class="muted">예: 5:200, 10:500 → 5레벨은 +200, 10레벨은 +500을 추가 요구</p>
        <div class="extra-rows" id="extra-rows" style="margin-top: 0.5rem; display: grid; gap: 0.75rem;"></div>
        <div class="actions" style="margin-top: 0.25rem;">
          <button class="secondary" id="add-extra-row">단일 레벨 입력 추가</button>
          <button class="secondary" id="apply-extra-xp">모든 단일 레벨 반영</button>
        </div>
        <p class="muted">입력 타입을 "직접 입력"(숫자) 또는 "수식"(예: <code>L * 50</code>)으로 설정할 수 있습니다.</p>
      </div>

      <div id="param-grid" class="grid" style="margin-top: 0.75rem;"></div>

      <div style="margin-top: 0.75rem;">
        <label for="advanced-json">고급 설정 (PIECEWISE/TABLE용 JSON)</label>
        <textarea id="advanced-json" rows="10" placeholder='{"segments": [{"minL":1,"maxL":10,"type":"LINEAR","params":{"m":20,"b":0}}]}'></textarea>
        <p class="muted">PIECEWISE: <code>{ "segments": [ { "minL": 1, "maxL": 10, "type": "LINEAR", "params": { "m": 20, "b": 0 } } ] }</code><br>TABLE: <code>{ "entries": [ {"level":1, "xp":100}, {"level":2, "xp":120} ] }</code></p>
      </div>

      <div class="actions">
        <button class="secondary" id="fill-power">POWER 추천값 채우기</button>
        <button class="secondary" id="fill-piecewise">PIECEWISE 예시 채우기</button>
        <button class="secondary" id="fill-logistic">LOGISTIC 완화 예시</button>
        <button class="primary" id="run-test">테스트 실행</button>
        <button class="secondary" id="send-test">테스트 설정 서버 전송</button>
      </div>
      <div class="status" id="test-status"></div>
      <div class="result-table" id="result-wrapper" hidden>
        <table>
          <thead>
            <tr>
              <th>L</th>
              <th>xp(L)</th>
              <th>추가XP(L)</th>
              <th>TotalXp(L)</th>
            </tr>
          </thead>
          <tbody id="result-body"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore,
      collection,
      getDocs,
      addDoc,
      setDoc,
      deleteDoc,
      doc,
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
    import { getFirebaseConfig } from "./firebase-config.js";

    const app = initializeApp(await getFirebaseConfig());
    const db = getFirestore(app);
    const docsRef = collection(db, "xpCurveDocs");
    const testRunsRef = collection(db, "xpCurveTestRuns");

    const docInputs = {
      id: document.getElementById("doc-id"),
      title: document.getElementById("doc-title"),
      desc: document.getElementById("doc-desc"),
      tags: document.getElementById("doc-tags"),
      content: document.getElementById("doc-content"),
    };
    const docStatus = document.getElementById("doc-status");
    const docTableBody = document.getElementById("doc-table-body");
    const loadLocalBtn = document.getElementById("load-local");
    const saveDocBtn = document.getElementById("save-doc");
    const resetDocBtn = document.getElementById("reset-doc");

    const paramGrid = document.getElementById("param-grid");
    const roundingSelect = document.getElementById("rounding");
    const typeSelect = document.getElementById("formula-type");
    const levelStartInput = document.getElementById("level-start");
    const levelEndInput = document.getElementById("level-end");
    const extraXpInput = document.getElementById("extra-xp");
    const extraRowsContainer = document.getElementById("extra-rows");
    const addExtraRowBtn = document.getElementById("add-extra-row");
    const applyExtraXpBtn = document.getElementById("apply-extra-xp");
    const advancedJson = document.getElementById("advanced-json");
    const testStatus = document.getElementById("test-status");
    const resultWrapper = document.getElementById("result-wrapper");
    const resultBody = document.getElementById("result-body");
    const fillPowerBtn = document.getElementById("fill-power");
    const fillPiecewiseBtn = document.getElementById("fill-piecewise");
    const fillLogisticBtn = document.getElementById("fill-logistic");
    const runTestBtn = document.getElementById("run-test");
    const sendTestBtn = document.getElementById("send-test");

    function setDocStatus(message, delay = 4500) {
      docStatus.textContent = message;
      if (delay) setTimeout(() => (docStatus.textContent = ""), delay);
    }

    function setTestStatus(message, delay = 4500) {
      testStatus.textContent = message;
      if (delay) setTimeout(() => (testStatus.textContent = ""), delay);
    }

    function resetDocForm() {
      docInputs.id.value = "xp_curve_formula_recommendations";
      docInputs.title.value = "XP Curve 수식 추천";
      docInputs.desc.value = "XP_Curve_Formula_Recommendations.md 기반 정책/수식 정리";
      docInputs.tags.value = "power,piecewise,exponential,logistic,table";
      docInputs.content.value = "";
      setDocStatus("문서 입력을 초기화했습니다.");
    }

    async function loadLocalMarkdown() {
      try {
        const res = await fetch("./XP_Curve_Formula_Recommendations.md");
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        docInputs.content.value = text;
        setDocStatus("로컬 MD 파일을 불러왔습니다. 저장 후 Firestore에 보관하세요.");
      } catch (error) {
        console.error(error);
        setDocStatus("로컬 파일을 불러오지 못했습니다. 브라우저에서 파일 접근이 허용되는지 확인하세요.");
      }
    }

    async function saveDocument() {
      const id = docInputs.id.value.trim() || "xp_curve_formula_recommendations";
      const title = docInputs.title.value.trim();
      const desc = docInputs.desc.value.trim();
      const tags = docInputs.tags.value
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);
      const content = docInputs.content.value;

      if (!title) {
        setDocStatus("제목을 입력하세요.");
        return;
      }
      if (!content.trim()) {
        setDocStatus("본문(Markdown)을 채워주세요.");
        return;
      }

      const payload = {
        title,
        description: desc,
        tags,
        content,
        updatedAt: new Date().toISOString(),
      };

      await setDoc(doc(docsRef, id), payload, { merge: true });
      setDocStatus(`'${id}' 문서를 저장했습니다.`);
      await loadDocuments();
    }

    async function loadDocuments() {
      docTableBody.innerHTML = "";
      const snapshot = await getDocs(docsRef);
      const rows = [];
      snapshot.forEach((snap) => rows.push({ id: snap.id, ...snap.data() }));
      rows.sort((a, b) => (b.updatedAt ?? "").localeCompare(a.updatedAt ?? ""));
      if (!rows.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 5;
        td.textContent = "저장된 문서가 없습니다.";
        tr.appendChild(td);
        docTableBody.appendChild(tr);
        return;
      }

      rows.forEach((row) => {
        const tr = document.createElement("tr");
        const tagTd = document.createElement("td");
        tagTd.append(
          ...(row.tags ?? []).map((tag) => {
            const span = document.createElement("span");
            span.className = "pill";
            span.textContent = tag;
            return span;
          })
        );

        const actionsTd = document.createElement("td");
        const loadBtn = document.createElement("button");
        loadBtn.className = "secondary";
        loadBtn.textContent = "불러오기";
        loadBtn.addEventListener("click", () => fillDocForm(row));

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "danger";
        deleteBtn.textContent = "삭제";
        deleteBtn.addEventListener("click", async () => {
          if (!confirm(`'${row.id}' 문서를 삭제할까요?`)) return;
          await deleteDoc(doc(docsRef, row.id));
          setDocStatus(`'${row.id}' 문서를 삭제했습니다.`);
          await loadDocuments();
        });

        actionsTd.append(loadBtn, deleteBtn);

        const cells = [
          row.id,
          row.title ?? "-",
          tagTd,
          row.updatedAt ? new Date(row.updatedAt).toLocaleString() : "-",
          actionsTd,
        ];

        cells.forEach((value) => {
          const td = document.createElement("td");
          if (value instanceof HTMLElement) {
            td.appendChild(value);
          } else {
            td.textContent = value;
          }
          tr.appendChild(td);
        });

        docTableBody.appendChild(tr);
      });
    }

    function fillDocForm(row) {
      docInputs.id.value = row.id ?? "";
      docInputs.title.value = row.title ?? "";
      docInputs.desc.value = row.description ?? "";
      docInputs.tags.value = (row.tags ?? []).join(",");
      docInputs.content.value = row.content ?? "";
      setDocStatus(`'${row.id}' 문서를 편집 중입니다.`);
    }

    const paramDefinitions = {
      POWER: [
        { key: "A", label: "A (스케일)", defaultValue: 50 },
        { key: "P", label: "P (곡률)", defaultValue: 1.6 },
        { key: "B", label: "B (오프셋)", defaultValue: 0 },
      ],
      EXPONENTIAL: [
        { key: "A", label: "A (시작 스케일)", defaultValue: 50 },
        { key: "R", label: "R (증가율)", defaultValue: 1.06, step: 0.01 },
        { key: "B", label: "B (오프셋)", defaultValue: 0 },
      ],
      LINEAR: [
        { key: "m", label: "m (기울기)", defaultValue: 20 },
        { key: "b", label: "b (절편)", defaultValue: 0 },
      ],
      LOGISTIC: [
        { key: "K", label: "K (포화 상한)", defaultValue: 600 },
        { key: "r", label: "r (기울기)", defaultValue: 0.08, step: 0.01 },
        { key: "L0", label: "L0 (전환점)", defaultValue: 40 },
        { key: "B", label: "B (오프셋)", defaultValue: 0 },
      ],
    };

    const paramInputs = new Map();

    function renderParamInputs(type) {
      paramGrid.innerHTML = "";
      paramInputs.clear();
      const defs = paramDefinitions[type];
      if (!defs) {
        const info = document.createElement("p");
        info.className = "muted";
        info.textContent = type === "PIECEWISE" || type === "TABLE"
          ? "PIECEWISE/TABLE은 아래 JSON 또는 텍스트를 채우세요."
          : "지원되는 파라미터가 없습니다.";
        paramGrid.appendChild(info);
        return;
      }

      defs.forEach(({ key, label, defaultValue, step }) => {
        const wrapper = document.createElement("div");
        const labelEl = document.createElement("label");
        labelEl.textContent = label;
        const input = document.createElement("input");
        input.type = "number";
        input.id = `param-${key}`;
        input.value = defaultValue;
        if (step !== undefined) input.step = step;
        wrapper.append(labelEl, input);
        paramGrid.appendChild(wrapper);
        paramInputs.set(key, input);
      });
    }

    function getRounding(mode) {
      switch (mode) {
        case "FLOOR":
          return Math.floor;
        case "ROUND":
          return Math.round;
        case "CEIL":
        default:
          return Math.ceil;
      }
    }

    function toNumber(value, fallback = 0) {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    }

    function clampLevelRange() {
      const start = Math.max(1, Math.floor(toNumber(levelStartInput.value, 1)));
      const end = Math.max(start, Math.floor(toNumber(levelEndInput.value, 20)));
      levelStartInput.value = start;
      levelEndInput.value = end;
      return { start, end };
    }

    function parseExtraXp(raw) {
      const map = new Map();
      const trimmed = raw.trim();
      if (!trimmed) return map;

      const tryAdd = (level, amount) => {
        const L = Math.floor(toNumber(level, NaN));
        const xp = Math.floor(toNumber(amount, NaN));
        if (!Number.isFinite(L) || !Number.isFinite(xp) || L < 1) return;
        if (xp === 0) return;
        map.set(L, xp);
      };

      try {
        const parsed = JSON.parse(trimmed);
        if (parsed && typeof parsed === "object") {
          Object.entries(parsed).forEach(([k, v]) => tryAdd(k, v));
          return map;
        }
      } catch (error) {
        // fallback below
      }

      trimmed
        .split(",")
        .map((part) => part.trim())
        .filter(Boolean)
        .forEach((pair) => {
          const [lvl, amt] = pair.split(":").map((p) => p.trim());
          tryAdd(lvl, amt);
        });

      return map;
    }

    function formatExtraXp(map) {
      const entries = Array.from(map.entries()).sort((a, b) => a[0] - b[0]);
      return entries.map(([lvl, amt]) => `${lvl}:${amt}`).join(", ");
    }

    function mapToObject(map) {
      const obj = {};
      map.forEach((value, key) => {
        obj[key] = value;
      });
      return obj;
    }

    const extraRows = [];

    function evaluateExtraExpression(expr, L) {
      const cleaned = expr.trim();
      if (!cleaned) throw new Error("수식을 입력하세요.");

      const allowed = /^[0-9+\-*/().,\sLMathpowexincosqrtlogabsmaxmin]+$/i;
      if (!allowed.test(cleaned)) {
        throw new Error("수식에 허용되지 않는 문자가 있습니다.");
      }

      const fn = new Function("L", "Math", `"use strict"; return ${cleaned};`);
      const value = fn(L, Math);
      const xp = Math.floor(value);
      if (!Number.isFinite(xp)) throw new Error("수식 결과가 유효한 숫자가 아닙니다.");
      return xp;
    }

    function createExtraRow(initial = {}) {
      const row = document.createElement("div");
      row.className = "grid";
      row.style.gridTemplateColumns = "repeat(auto-fit, minmax(140px, 1fr))";
      row.style.gap = "0.35rem 0.65rem";

      const levelWrapper = document.createElement("div");
      const levelLabel = document.createElement("label");
      levelLabel.textContent = "단일 레벨";
      const levelInput = document.createElement("input");
      levelInput.type = "number";
      levelInput.min = "1";
      levelInput.placeholder = "예: 10";
      if (initial.level) levelInput.value = initial.level;
      levelWrapper.append(levelLabel, levelInput);

      const typeWrapper = document.createElement("div");
      const typeLabel = document.createElement("label");
      typeLabel.textContent = "입력 타입";
      const typeSelect = document.createElement("select");
      [
        { value: "VALUE", label: "직접 입력" },
        { value: "FORMULA", label: "수식" },
      ].forEach(({ value, label }) => {
        const opt = document.createElement("option");
        opt.value = value;
        opt.textContent = label;
        typeSelect.appendChild(opt);
      });
      if (initial.type) typeSelect.value = initial.type;
      typeWrapper.append(typeLabel, typeSelect);

      const valueWrapper = document.createElement("div");
      const valueLabel = document.createElement("label");
      valueLabel.textContent = "값/수식";
      const valueInput = document.createElement("input");
      valueInput.type = "text";
      valueInput.placeholder = "예: 100 또는 L * 50";
      if (initial.value !== undefined) valueInput.value = initial.value;
      valueWrapper.append(valueLabel, valueInput);

      const removeWrapper = document.createElement("div");
      removeWrapper.style.display = "flex";
      removeWrapper.style.alignItems = "flex-end";
      const removeBtn = document.createElement("button");
      removeBtn.className = "danger";
      removeBtn.textContent = "삭제";
      removeBtn.type = "button";
      removeBtn.addEventListener("click", () => {
        extraRowsContainer.removeChild(row);
        const idx = extraRows.findIndex((item) => item.wrapper === row);
        if (idx >= 0) extraRows.splice(idx, 1);
      });
      removeWrapper.appendChild(removeBtn);

      row.append(levelWrapper, typeWrapper, valueWrapper, removeWrapper);
      extraRowsContainer.appendChild(row);
      const entry = { wrapper: row, levelInput, typeSelect, valueInput };
      extraRows.push(entry);
      return entry;
    }

    function applyExtraXpInputs() {
      const map = parseExtraXp(extraXpInput.value);
      const errors = [];
      const updates = [];

      extraRows.forEach(({ levelInput, valueInput, typeSelect }) => {
        const L = Math.floor(toNumber(levelInput.value, NaN));
        const raw = valueInput.value.trim();
        const mode = typeSelect.value;

        if (!Number.isFinite(L) || L < 1) {
          errors.push("레벨은 1 이상의 숫자로 입력하세요.");
          return;
        }
        if (!raw) {
          errors.push(`${L}레벨 수치를 입력하세요.`);
          return;
        }

        let xp = Number.NaN;
        try {
          xp = mode === "FORMULA" ? evaluateExtraExpression(raw, L) : Math.floor(toNumber(raw, NaN));
        } catch (error) {
          errors.push(`${L}레벨: ${error.message}`);
          return;
        }

        if (!Number.isFinite(xp) || xp < 0) {
          errors.push(`${L}레벨 추가 XP는 0 이상이어야 합니다.`);
          return;
        }

        if (xp === 0) {
          map.delete(L);
          updates.push(`${L}레벨 제거`);
        } else {
          map.set(L, xp);
          updates.push(`${L}레벨=${xp.toLocaleString()}`);
        }
      });

      if (errors.length) {
        setTestStatus(errors.join("\n"), 6000);
        return;
      }

      if (!updates.length) {
        setTestStatus("적용할 단일 레벨 입력이 없습니다.");
        return;
      }

      extraXpInput.value = formatExtraXp(map);
      setTestStatus(`단일 레벨 추가 XP 반영: ${updates.join(", ")}`);
    }

    function buildFormulaConfig() {
      const type = typeSelect.value;
      const rounding = roundingSelect.value;
      const extraXp = parseExtraXp(extraXpInput.value);
      if (type === "PIECEWISE" || type === "TABLE") {
        let parsed = {};
        if (advancedJson.value.trim()) {
          try {
            parsed = JSON.parse(advancedJson.value);
          } catch (error) {
            throw new Error("고급 설정 JSON을 파싱하지 못했습니다.");
          }
        }
        return { type, params: parsed, rounding, extraXp };
      }

      const params = {};
      const defs = paramDefinitions[type] ?? [];
      defs.forEach(({ key }) => {
        params[key] = toNumber(paramInputs.get(key)?.value ?? 0, 0);
      });
      return { type, params, rounding, extraXp };
    }

    function evaluateFormula(config, level) {
      const { type, params, rounding } = config;
      const round = getRounding(rounding);
      const L = level;
      let xp = Number.NaN;

      switch (type) {
        case "POWER": {
          const { A = 0, P = 1, B = 0 } = params;
          xp = A * Math.pow(L, P) + B;
          break;
        }
        case "EXPONENTIAL": {
          const { A = 0, R = 1, B = 0 } = params;
          xp = A * Math.pow(R, L - 1) + B;
          break;
        }
        case "LINEAR": {
          const { m = 0, b = 0 } = params;
          xp = m * L + b;
          break;
        }
        case "LOGISTIC": {
          const { K = 0, r = 0.1, L0 = 0, B = 0 } = params;
          xp = K / (1 + Math.exp(-r * (L - L0))) + B;
          break;
        }
        case "PIECEWISE": {
          const segments = params?.segments ?? [];
          const segment = segments.find((s) => L >= s.minL && L <= s.maxL);
          if (!segment) return { xp: null, warning: "해당 레벨에 맞는 세그먼트가 없습니다." };
          const inner = evaluateFormula({ type: segment.type, params: segment.params ?? {}, rounding }, level);
          if (inner.warning) return inner;
          xp = inner.xp;
          break;
        }
        case "TABLE": {
          const entry = (params?.entries ?? []).find((e) => e.level === L);
          if (!entry) return { xp: null, warning: "테이블에 해당 레벨 값이 없습니다." };
          xp = entry.xp;
          break;
        }
        default:
          return { xp: null, warning: "지원하지 않는 타입입니다." };
      }

      if (!Number.isFinite(xp)) {
        return { xp: null, warning: "수식 결과가 유효하지 않습니다 (NaN/Infinity)." };
      }
      const rounded = round(xp);
      if (rounded <= 0) {
        return { xp: rounded, warning: "xp(L)이 0 이하입니다. 파라미터를 확인하세요." };
      }
      return { xp: rounded };
    }

    function runTest() {
      try {
        const config = buildFormulaConfig();
        const { start, end } = clampLevelRange();
        const rows = [];
        let total = 0;
        let lastWarning = "";

        for (let L = start; L <= end; L++) {
          const result = evaluateFormula(config, L);
          if (result.warning) lastWarning = result.warning;
          const extra = config.extraXp.get(L) ?? 0;
          const xpValue = Math.max(0, (result.xp ?? 0) + extra);
          total += xpValue;
          rows.push({ L, xp: xpValue, extra, total });
        }

        renderResults(rows);
        setTestStatus(lastWarning ? `경고: ${lastWarning}` : "테스트 완료");
      } catch (error) {
        console.error(error);
        setTestStatus(error.message || "테스트 중 오류가 발생했습니다.");
      }
    }

    async function sendTestConfigToServer() {
      try {
        const config = buildFormulaConfig();
        const { start, end } = clampLevelRange();
        const previewRows = [];
        let warning = "";
        const previewEnd = Math.min(end, start + 4);

        for (let L = start; L <= previewEnd; L++) {
          const result = evaluateFormula(config, L);
          if (result.warning) warning = result.warning;
          const extra = config.extraXp.get(L) ?? 0;
          const xpValue = Math.max(0, (result.xp ?? 0) + extra);
          previewRows.push({ L, xp: xpValue, extra });
        }

        const payload = {
          createdAt: new Date().toISOString(),
          type: config.type,
          params: config.params,
          rounding: config.rounding,
          extraXp: mapToObject(config.extraXp),
          levelStart: start,
          levelEnd: end,
          preview: previewRows,
        };
        if (warning) payload.warning = warning;

        await addDoc(testRunsRef, payload);
        setTestStatus("테스트 설정을 서버로 전송했습니다.");
      } catch (error) {
        console.error(error);
        setTestStatus(error.message || "테스트 설정을 전송하지 못했습니다.");
      }
    }

    function renderResults(rows) {
      resultBody.innerHTML = "";
      rows.forEach((row) => {
        const tr = document.createElement("tr");
        [row.L, row.xp, row.extra, row.total].forEach((value) => {
          const td = document.createElement("td");
          td.textContent = Number.isFinite(value) ? value.toLocaleString() : "-";
          tr.appendChild(td);
        });
        resultBody.appendChild(tr);
      });
      resultWrapper.hidden = rows.length === 0;
    }

    function applyPreset(type) {
      typeSelect.value = type;
      renderParamInputs(type);
      switch (type) {
        case "POWER": {
          roundingSelect.value = "CEIL";
          paramInputs.get("A").value = 50;
          paramInputs.get("P").value = 1.6;
          paramInputs.get("B").value = 0;
          advancedJson.value = "";
          break;
        }
        case "PIECEWISE": {
          roundingSelect.value = "CEIL";
          advancedJson.value = JSON.stringify(
            {
              segments: [
                { minL: 1, maxL: 10, type: "LINEAR", params: { m: 20, b: 0 } },
                { minL: 11, maxL: 30, type: "POWER", params: { A: 30, P: 1.4, B: 0 } },
                { minL: 31, maxL: 200, type: "POWER", params: { A: 50, P: 1.8, B: 0 } },
              ],
            },
            null,
            2
          );
          break;
        }
        case "LOGISTIC": {
          roundingSelect.value = "CEIL";
          paramInputs.get("K").value = 600;
          paramInputs.get("r").value = 0.08;
          paramInputs.get("L0").value = 45;
          paramInputs.get("B").value = 0;
          advancedJson.value = "";
          break;
        }
      }
    }

    function init() {
      renderParamInputs(typeSelect.value);
      createExtraRow({ level: 10, value: 100, type: "VALUE" });
      resetDocForm();
      loadDocuments().catch((error) => {
        console.error(error);
        setDocStatus("Firestore에서 문서를 불러오는 중 오류가 발생했습니다.");
      });
    }

    loadLocalBtn.addEventListener("click", loadLocalMarkdown);
    saveDocBtn.addEventListener("click", async () => {
      saveDocBtn.disabled = true;
      try {
        await saveDocument();
      } catch (error) {
        console.error(error);
        setDocStatus("저장 중 오류가 발생했습니다.");
      } finally {
        saveDocBtn.disabled = false;
      }
    });
    resetDocBtn.addEventListener("click", resetDocForm);

    typeSelect.addEventListener("change", () => renderParamInputs(typeSelect.value));
    runTestBtn.addEventListener("click", runTest);
    addExtraRowBtn.addEventListener("click", () => createExtraRow());
    applyExtraXpBtn.addEventListener("click", applyExtraXpInputs);
    sendTestBtn.addEventListener("click", async () => {
      sendTestBtn.disabled = true;
      try {
        await sendTestConfigToServer();
      } finally {
        sendTestBtn.disabled = false;
      }
    });
    fillPowerBtn.addEventListener("click", () => applyPreset("POWER"));
    fillPiecewiseBtn.addEventListener("click", () => applyPreset("PIECEWISE"));
    fillLogisticBtn.addEventListener("click", () => applyPreset("LOGISTIC"));

    init();
  </script>
</body>
</html>
