<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AbilitySpec 관리 (Firestore)</title>
    <style>
    :root {
      color-scheme: light dark;
      font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      background: #0f172a;
      color: #e2e8f0;
    }

    .top-nav {
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.9rem 1.5rem;
      margin: -1.5rem -1.5rem 1.25rem;
      background: rgba(11, 18, 32, 0.8);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid #1f2937;
    }

    .nav-brand {
      font-weight: 800;
      letter-spacing: -0.01em;
    }

    .nav-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .nav-link {
      color: #cbd5e1;
      text-decoration: none;
      padding: 0.45rem 0.8rem;
      border-radius: 10px;
      border: 1px solid transparent;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .nav-link:hover {
      background: #111827;
      border-color: #1f2937;
      color: #e2e8f0;
    }

    .nav-link.active {
      background: linear-gradient(90deg, #3b82f6, #06b6d4);
      color: #0b1220;
      border-color: transparent;
    }

    h1 {
      margin-top: 0;
    }

    .container {
      display: grid;
      gap: 1.5rem;
    }

    .card {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .card h2 {
      margin-top: 0;
      margin-bottom: 0.35rem;
    }

    .step-label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      background: #0b1220;
      border: 1px solid #1f2937;
      font-weight: 700;
      font-size: 0.85rem;
      color: #a5b4fc;
    }

    .muted {
      color: #94a3b8;
      font-size: 0.95rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.75rem 1rem;
    }

    label {
      display: block;
      font-weight: 700;
      margin-bottom: 0.3rem;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #334155;
      background: #0b1220;
      color: #e2e8f0;
    }

    textarea {
      min-height: 72px;
      resize: vertical;
    }

    input[type="checkbox"] {
      transform: scale(1.05);
      accent-color: #3b82f6;
    }

    .field-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      background: #0b1220;
      border: 1px solid #1f2937;
      font-size: 0.9rem;
      color: #cbd5e1;
    }

    .hidden {
      display: none !important;
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 0.6rem 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, filter 0.15s ease;
    }

    button.primary {
      background: linear-gradient(90deg, #3b82f6, #06b6d4);
      color: #0b1220;
    }

    button.secondary {
      background: #1f2937;
      color: #e2e8f0;
      border: 1px solid #334155;
    }

    button.danger {
      background: #ef4444;
      color: #0b1220;
    }

    button:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }

    th, td {
      border-bottom: 1px solid #1f2937;
      padding: 0.6rem;
      text-align: left;
    }

    th {
      color: #cbd5e1;
      font-size: 0.95rem;
    }

    tr:hover td {
      background: #0b1220;
    }

    .status {
      margin-top: 0.75rem;
      padding: 0.6rem 0.8rem;
      border-radius: 10px;
      background: #0b1220;
      border: 1px solid #1f2937;
      color: #cbd5e1;
      min-height: 1.4rem;
      white-space: pre-line;
    }

    .section-subtitle {
      margin-top: -0.25rem;
      margin-bottom: 0.65rem;
      color: #a5b4fc;
      font-weight: 600;
    }

    .two-cols {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1rem;
    }

    .helper {
      color: #9ca3af;
      font-size: 0.9rem;
      margin-top: 0.25rem;
      line-height: 1.5;
    }

    .preview-card {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(14, 165, 233, 0.08));
      border: 1px solid #1f2937;
    }

    .preview-title {
      font-weight: 800;
      margin-bottom: 0.25rem;
    }

    .preview-body {
      color: #e5e7eb;
      white-space: pre-line;
    }

    .required-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.1rem 0.4rem;
      margin-left: 0.35rem;
      border-radius: 999px;
      background: rgba(248, 113, 113, 0.15);
      color: #fca5a5;
      font-weight: 700;
      font-size: 0.8rem;
      border: 1px solid rgba(248, 113, 113, 0.35);
    }

    .stepper {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .step-chip {
      border: 1px solid #1f2937;
      background: #0b1220;
      color: #e5e7eb;
      border-radius: 10px;
      padding: 0.45rem 0.8rem;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .step-chip.active {
      border-color: #3b82f6;
      color: #bfdbfe;
      background: rgba(59, 130, 246, 0.12);
    }

    .step-nav {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .step-hidden {
      display: none !important;
    }
    </style>
  </head>
  <body>
    <nav class="top-nav">
      <div class="nav-brand">Ability 관리 도구</div>
      <div class="nav-links">
        <a class="nav-link" href="base-stats-firestore.html">BaseStat 프리셋</a>
        <a class="nav-link" href="growth-base-stats-firestore.html">GrowthBaseStat 프리셋</a>
        <a class="nav-link" href="combat-stats-firestore.html">CombatStats 관리</a>
        <a class="nav-link" href="combat-dps-tester.html">Combat DPS 테스트</a>
        <a class="nav-link" href="effect-system-firestore.html">EffectSpec 관리</a>
        <a class="nav-link active" href="ability-system-firestore.html">AbilitySpec 관리</a>
      </div>
    </nav>

    <div class="container">
      <header class="card">
        <div class="step-label">AbilitySystem.md 기반</div>
        <h1>AbilitySpec 추가/수정/삭제</h1>
        <p class="muted">하나의 스킬을 정의하고, 랭크/쿨다운/코스트/효과 묶음과 전달 스펙을 한 번에 관리합니다. 필수 값만 노출되며 검증 룰은 문서 규칙을 따릅니다.</p>
      </header>

      <section class="card">
        <div class="step-label">프리셋</div>
        <h2>샘플 Ability 불러오기</h2>
        <p class="section-subtitle">LoL 스타일 예시를 불러와 빠르게 수정하세요. 저장 자체에는 영향을 주지 않습니다.</p>
        <div class="grid">
          <div>
            <label for="preset-select">프리셋 선택</label>
            <select id="preset-select"></select>
          </div>
        </div>
        <div class="actions">
          <button class="secondary" id="apply-preset-btn">프리셋 불러오기</button>
        </div>
      </section>

      <section class="card preview-card">
        <h2 class="preview-title">현재 Ability 설명 (요약)</h2>
        <p class="helper">입력값이 바뀔 때마다 실시간으로 서술합니다. 슬롯/랭크 규칙/효과 구성/전달 방식을 한 문장으로 풀어줍니다.</p>
        <div class="preview-body" id="ability-preview">필수 필드를 입력하면 요약이 갱신됩니다.</div>
      </section>

      <section class="card" data-step="1">
        <div class="step-label">1단계 · 정체성</div>
        <h2>Ability ID / Slot</h2>
        <p class="section-subtitle">AbilitySpec의 유니크 ID와 슬롯(Passive|A|U)을 지정합니다.</p>
        <div class="grid">
          <div>
            <label for="ability-id">abilityId <span class="required-pill">필수</span></label>
            <input id="ability-id" type="text" placeholder="예: Hero01_A1" />
            <p class="helper">전역 유니크 값. 공백은 저장 시 자동 언더스코어 처리됩니다.</p>
          </div>
          <div>
            <label for="slot">slot <span class="required-pill">필수</span></label>
            <select id="slot"></select>
            <p class="helper">Passive | A | U 중 하나를 선택합니다.</p>
          </div>
        </div>
      </section>

      <section class="card" data-step="2">
        <div class="step-label">2단계 · 랭크 규칙</div>
        <h2>rankRules</h2>
        <p class="section-subtitle">랭크 최대치와 랭크별 쿨다운/코스트를 입력합니다. 배열 길이는 maxRank와 일치해야 합니다.</p>
        <div class="grid">
          <div>
            <label for="max-rank">maxRank <span class="required-pill">필수</span></label>
            <input id="max-rank" type="number" min="1" placeholder="예: 3" />
            <p class="helper">1 이상이어야 합니다. Passive는 보통 1, A/U는 3~5 권장.</p>
          </div>
          <div>
            <label for="cooldown-by-rank">cooldownByRank (쉼표 숫자)</label>
            <input id="cooldown-by-rank" type="text" placeholder="예: 8,7.5,7" />
            <p class="helper">길이 = maxRank. Passive는 보통 0.</p>
          </div>
          <div>
            <label for="cost-by-rank">costByRank (쉼표 숫자)</label>
            <input id="cost-by-rank" type="text" placeholder="예: 60,65,70" />
            <p class="helper">길이 = maxRank. 자원 단위는 게임 공통 룰로 해석됩니다.</p>
          </div>
        </div>
      </section>

      <section class="card" data-step="3">
        <div class="step-label">3단계 · Effect 구성</div>
        <h2>effects</h2>
        <p class="section-subtitle">Ability를 구성하는 EffectSpec 배열을 입력합니다. effect-system-firestore.html에서 만든 effectId를 참조하세요.</p>
        <div class="grid">
          <div>
            <label for="effect-ids">effectId 목록 (쉼표로 구분)</label>
            <input id="effect-ids" type="text" placeholder="예: A1_Damage, A1_Slow" />
            <p class="helper">간단히 effectId만 입력하면 자동으로 객체 배열로 변환됩니다.</p>
          </div>
          <div>
            <label for="effects-json">effects JSON (선택)</label>
            <textarea id="effects-json" placeholder='예: [{"effectId":"A1_Damage","type":"Damage"}]'></textarea>
            <p class="helper">정교한 설정이 필요하면 JSON 배열로 직접 입력하세요. effectId 중복은 방지됩니다.</p>
          </div>
        </div>
      </section>

      <section class="card" data-step="4">
        <div class="step-label">4단계 · 전달 방식</div>
        <h2>deliverySpec (선택)</h2>
        <p class="section-subtitle">투사체/범위/즉발 등 전달 방식을 정의합니다. 필요 없는 경우 비워두세요.</p>
        <div class="grid">
          <div>
            <label for="delivery-type">deliverySpec.type</label>
            <select id="delivery-type"></select>
            <p class="helper">InstantSingleTarget | InstantAoE | Projectile | Zone | Beam 중 선택.</p>
          </div>
          <div>
            <label for="delivery-range">range</label>
            <input id="delivery-range" type="number" min="0" step="0.01" placeholder="예: 650" />
          </div>
          <div>
            <label for="delivery-radius">radius</label>
            <input id="delivery-radius" type="number" min="0" step="0.01" placeholder="예: 400" />
          </div>
          <div>
            <label for="delivery-center-ref">centerRef</label>
            <select id="delivery-center-ref"></select>
          </div>
          <div>
            <label for="projectile-speed">projectileSpeed</label>
            <input id="projectile-speed" type="number" min="0" step="0.01" placeholder="예: 1800" />
            <p class="helper">Projectile 전용.</p>
          </div>
          <div>
            <label for="max-distance">maxDistance</label>
            <input id="max-distance" type="number" min="0" step="0.01" placeholder="예: 1200" />
          </div>
          <div>
            <label for="collision-rule">collisionRule</label>
            <select id="collision-rule"></select>
          </div>
          <div>
            <label for="duration">duration</label>
            <input id="duration" type="number" min="0" step="0.01" placeholder="예: 6" />
            <p class="helper">Zone 전용 지속 시간.</p>
          </div>
          <div>
            <label for="tick-interval">tickInterval</label>
            <input id="tick-interval" type="number" min="0" step="0.01" placeholder="예: 1" />
          </div>
        </div>
      </section>

      <section class="card" data-step="5">
        <div class="step-label">5단계 · 검증 및 이동</div>
        <h2>단계 이동</h2>
        <p class="section-subtitle">한 번에 한 단계씩 입력하세요.</p>
        <div class="stepper" id="step-indicator"></div>
        <div class="step-nav">
          <button class="secondary" id="prev-step-btn">이전 단계</button>
          <button class="secondary" id="next-step-btn">다음 단계</button>
        </div>
      </section>

      <section class="card" id="save-load-section">
        <h2>저장 / 로드</h2>
        <div class="actions">
          <button class="primary" id="save-btn">Ability 저장/업데이트</button>
          <button class="secondary" id="reset-btn">새 Ability 작성</button>
        </div>
        <div class="status" id="status"></div>
      </section>

      <section class="card" id="table-section">
        <h2>저장된 Ability 목록</h2>
        <div class="muted">Firestore collection: <code>abilitySpecs</code>. effectId 목록과 랭크 규칙을 빠르게 확인할 수 있습니다.</div>
        <table id="ability-table">
          <thead>
            <tr>
              <th>abilityId</th>
              <th>slot</th>
              <th>maxRank</th>
              <th>effects</th>
              <th>deliverySpec</th>
              <th>작업</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
      import {
        getFirestore,
        collection,
        getDocs,
        setDoc,
        deleteDoc,
        doc,
      } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
      import { getFirebaseConfig } from "./firebase-config.js";

      const app = initializeApp(await getFirebaseConfig());
      const db = getFirestore(app);
      const abilitiesRef = collection(db, "abilitySpecs");

      const selects = {
        slot: document.getElementById("slot"),
        deliveryType: document.getElementById("delivery-type"),
        centerRef: document.getElementById("delivery-center-ref"),
        collisionRule: document.getElementById("collision-rule"),
      };

      const slotOptions = ["Passive", "A", "U"];
      const deliveryTypeOptions = ["", "InstantSingleTarget", "InstantAoE", "Projectile", "Zone", "Beam"];
      const centerRefOptions = ["", "CasterPos", "TargetPos", "CursorPos", "ProjectilePos", "ZoneCenter"];
      const collisionRuleOptions = ["", "FirstHit", "Pierce", "StopOnWall", "StopOnUnit", "Reflectable"];

      const presetSelect = document.getElementById("preset-select");
      const applyPresetBtn = document.getElementById("apply-preset-btn");
      const statusEl = document.getElementById("status");
      const previewEl = document.getElementById("ability-preview");
      const abilityTableBody = document.querySelector("#ability-table tbody");
      const saveBtn = document.getElementById("save-btn");
      const resetBtn = document.getElementById("reset-btn");
      const stepSections = Array.from(document.querySelectorAll("[data-step]"));
      const stepIndicator = document.getElementById("step-indicator");
      const prevStepBtn = document.getElementById("prev-step-btn");
      const nextStepBtn = document.getElementById("next-step-btn");
      let currentStepIndex = 0;

      const abilityPresets = [
        {
          label: "Hero01_Passive (적중 시 추가 피해)",
          ability: {
            abilityId: "Hero01_Passive",
            slot: "Passive",
            rankRules: { maxRank: 1, cooldownByRank: [0], costByRank: [0] },
            effects: [{ effectId: "Passive_OnHitBonus", type: "Damage", trigger: { triggerType: "OnHit" } }],
          },
        },
        {
          label: "Hero01_A1 (단일 타겟 딜 + 둔화)",
          ability: {
            abilityId: "Hero01_A1",
            slot: "A",
            rankRules: {
              maxRank: 5,
              cooldownByRank: [8, 7.5, 7, 6.5, 6],
              costByRank: [60, 65, 70, 75, 80],
            },
            effects: [
              { effectId: "A1_Damage", type: "Damage", trigger: { triggerType: "OnCastCommit" } },
              { effectId: "A1_Slow", type: "ApplyStatus", trigger: { triggerType: "OnCastCommit" } },
            ],
            deliverySpec: { type: "InstantSingleTarget", range: 650 },
          },
        },
        {
          label: "Hero01_U (광역 보호막 + 이속)",
          ability: {
            abilityId: "Hero01_U",
            slot: "U",
            rankRules: {
              maxRank: 3,
              cooldownByRank: [18, 16, 14],
              costByRank: [80, 90, 100],
            },
            effects: [
              { effectId: "U_Shield", type: "Shield", trigger: { triggerType: "OnCastCommit" } },
              { effectId: "U_MoveSpeed", type: "ApplyStatus", trigger: { triggerType: "OnCastCommit" } },
            ],
            deliverySpec: { type: "InstantAoE", radius: 450, centerRef: "CasterPos" },
          },
        },
      ];

      function populateSelect(selectEl, options) {
        selectEl.innerHTML = "";
        options.forEach((value) => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = value || "(선택)";
          selectEl.appendChild(option);
        });
      }

      populateSelect(selects.slot, slotOptions);
      populateSelect(selects.deliveryType, deliveryTypeOptions);
      populateSelect(selects.centerRef, centerRefOptions);
      populateSelect(selects.collisionRule, collisionRuleOptions);
      populateSelect(presetSelect, abilityPresets.map((p) => p.label));

      function renderStepIndicator() {
        stepIndicator.innerHTML = "";
        stepSections.forEach((section, index) => {
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = "step-chip";
          chip.textContent = `${index + 1}단계`;
          chip.addEventListener("click", () => showStep(index));
          stepIndicator.appendChild(chip);
        });
        updateStepChips();
      }

      function updateStepChips() {
        const chips = stepIndicator.querySelectorAll(".step-chip");
        chips.forEach((chip, index) => {
          chip.classList.toggle("active", index === currentStepIndex);
        });
      }

      function showStep(index) {
        currentStepIndex = Math.max(0, Math.min(stepSections.length - 1, index));
        stepSections.forEach((section, idx) => {
          section.classList.toggle("step-hidden", idx !== currentStepIndex);
        });
        updateStepChips();
      }

      prevStepBtn.addEventListener("click", () => showStep(currentStepIndex - 1));
      nextStepBtn.addEventListener("click", () => showStep(currentStepIndex + 1));

      function parseNumber(value) {
        if (value === undefined || value === null) return undefined;
        const num = Number(value);
        return Number.isFinite(num) ? num : undefined;
      }

      function parseNumberArray(raw) {
        if (!raw) return [];
        return raw
          .split(",")
          .map((v) => parseNumber(v.trim()))
          .filter((v) => Number.isFinite(v));
      }

      function parseJSONSafe(value, { silent } = {}) {
        if (!value) return undefined;
        try {
          return JSON.parse(value);
        } catch (error) {
          if (!silent) setStatus("JSON 형식이 올바르지 않습니다. 콘솔을 확인하세요.");
          console.warn(error);
          return undefined;
        }
      }

      function pruneEmpty(value) {
        if (Array.isArray(value)) {
          const cleaned = value
            .map((item) => pruneEmpty(item))
            .filter((item) => item !== undefined && item !== null && (typeof item !== "object" || Object.keys(item).length));
          return cleaned.length ? cleaned : undefined;
        }
        if (value && typeof value === "object") {
          const result = {};
          Object.entries(value).forEach(([key, val]) => {
            const cleanedVal = pruneEmpty(val);
            if (cleanedVal !== undefined && cleanedVal !== null && cleanedVal !== "") result[key] = cleanedVal;
          });
          return Object.keys(result).length ? result : undefined;
        }
        return value === "" ? undefined : value;
      }

      function buildEffects() {
        const ids = document.getElementById("effect-ids").value;
        const json = parseJSONSafe(document.getElementById("effects-json").value, { silent: true });
        let effects = [];

        if (Array.isArray(json)) {
          effects = json;
        } else if (ids.trim()) {
          effects = ids
            .split(",")
            .map((id) => id.trim())
            .filter(Boolean)
            .map((id) => ({ effectId: id }));
        }

        if (!Array.isArray(effects)) {
          setStatus("effects 입력이 올바르지 않습니다.");
          return undefined;
        }

        const unique = new Set();
        const deduped = [];
        for (const effect of effects) {
          if (!effect?.effectId) continue;
          const id = effect.effectId;
          if (unique.has(id)) continue;
          unique.add(id);
          deduped.push(effect);
        }
        return deduped;
      }

      function buildDeliverySpec() {
        const delivery = pruneEmpty({
          type: selects.deliveryType.value || undefined,
          range: parseNumber(document.getElementById("delivery-range").value),
          radius: parseNumber(document.getElementById("delivery-radius").value),
          centerRef: selects.centerRef.value || undefined,
          projectileSpeed: parseNumber(document.getElementById("projectile-speed").value),
          maxDistance: parseNumber(document.getElementById("max-distance").value),
          collisionRule: selects.collisionRule.value || undefined,
          duration: parseNumber(document.getElementById("duration").value),
          tickInterval: parseNumber(document.getElementById("tick-interval").value),
        });
        return delivery;
      }

      function assembleAbility({ silentJSON = false } = {}) {
        const maxRank = parseNumber(document.getElementById("max-rank").value);
        const cooldownByRank = parseNumberArray(document.getElementById("cooldown-by-rank").value);
        const costByRank = parseNumberArray(document.getElementById("cost-by-rank").value);
        const effects = buildEffects();

        const ability = pruneEmpty({
          abilityId: document.getElementById("ability-id").value.trim(),
          slot: selects.slot.value,
          rankRules: pruneEmpty({
            maxRank,
            cooldownByRank: cooldownByRank.length ? cooldownByRank : undefined,
            costByRank: costByRank.length ? costByRank : undefined,
          }),
          effects: effects ?? [],
          deliverySpec: buildDeliverySpec(),
        });

        if (!silentJSON) {
          const errors = validateAbility(ability);
          if (errors.length) {
            setStatus(errors.join("\n"));
            return undefined;
          }
        }

        return ability;
      }

      function validateAbility(ability) {
        const errors = [];
        if (!ability?.abilityId) errors.push("abilityId를 입력하세요.");
        if (!ability?.slot) errors.push("slot을 선택하세요.");

        const { rankRules } = ability || {};
        if (!rankRules?.maxRank || rankRules.maxRank < 1) {
          errors.push("rankRules.maxRank는 1 이상이어야 합니다.");
        }
        const maxRank = rankRules?.maxRank;
        const checkArrayLength = (arr, label) => {
          if (!arr) return;
          if (arr.some((v) => v < 0)) errors.push(`${label}에 음수는 허용되지 않습니다.`);
          if (maxRank && arr.length !== maxRank) errors.push(`${label} 길이는 maxRank(${maxRank})와 같아야 합니다.`);
        };
        checkArrayLength(rankRules?.cooldownByRank, "cooldownByRank");
        checkArrayLength(rankRules?.costByRank, "costByRank");

        if (!ability?.effects?.length) {
          errors.push("effects는 최소 1개 effectId를 권장합니다.");
        }

        return errors;
      }

      function describeAbility(ability) {
        if (!ability) return "필수 필드를 채우면 요약이 표시됩니다.";
        const lines = [];
        const head = `${ability.abilityId || "새 Ability"} — ${ability.slot || "슬롯 미선택"}`;
        lines.push(head);

        if (ability.rankRules) {
          const { maxRank, cooldownByRank, costByRank } = ability.rankRules;
          const rankBits = [];
          if (maxRank !== undefined) rankBits.push(`maxRank ${maxRank}`);
          if (cooldownByRank?.length) rankBits.push(`CD ${cooldownByRank.join("/")}`);
          if (costByRank?.length) rankBits.push(`Cost ${costByRank.join("/")}`);
          if (rankBits.length) lines.push(`랭크: ${rankBits.join(" · ")}`);
        }

        if (ability.effects?.length) {
          const names = ability.effects.map((e) => e.effectId).filter(Boolean);
          lines.push(`효과: ${names.join(", ")}`);
        }

        if (ability.deliverySpec?.type) {
          const d = ability.deliverySpec;
          const parts = [`type=${d.type}`];
          if (d.range !== undefined) parts.push(`range ${d.range}`);
          if (d.radius !== undefined) parts.push(`radius ${d.radius}`);
          if (d.centerRef) parts.push(`center=${d.centerRef}`);
          if (d.projectileSpeed !== undefined) parts.push(`speed ${d.projectileSpeed}`);
          if (d.collisionRule) parts.push(`collision=${d.collisionRule}`);
          lines.push(`전달: ${parts.join(", ")}`);
        }

        return `• ${lines.join("\n• ")}`;
      }

      function buildTooltip(ability) {
        if (!ability?.abilityId) return "";
        const id = ability.abilityId;
        const slot = ability.slot ? `(${ability.slot})` : "";
        const effects = ability.effects?.map((e) => e.effectId).filter(Boolean).join(", ") || "정의 필요";
        const rank = ability.rankRules?.maxRank ? `최대 ${ability.rankRules.maxRank} 랭크` : "랭크 미설정";
        return `${id} ${slot}: ${rank}. 효과: ${effects}.`;
      }

      function refreshPreview() {
        const ability = assembleAbility({ silentJSON: true });
        if (!ability) {
          previewEl.textContent = "필수 필드를 채우면 요약이 표시됩니다.";
          return;
        }
        const tooltip = buildTooltip(ability);
        const detail = describeAbility(ability);
        const combined = tooltip ? `${tooltip}\n\n${detail}` : detail;
        previewEl.textContent = combined;
      }

      function setStatus(message) {
        statusEl.textContent = message;
      }

      function fillForm(ability) {
        document.getElementById("ability-id").value = ability.abilityId ?? "";
        selects.slot.value = ability.slot ?? "";
        document.getElementById("max-rank").value = ability.rankRules?.maxRank ?? "";
        document.getElementById("cooldown-by-rank").value = (ability.rankRules?.cooldownByRank ?? []).join(", ");
        document.getElementById("cost-by-rank").value = (ability.rankRules?.costByRank ?? []).join(", ");
        document.getElementById("effect-ids").value = (ability.effects ?? []).map((e) => e.effectId).filter(Boolean).join(", ");
        document.getElementById("effects-json").value = ability.effects?.length ? JSON.stringify(ability.effects, null, 2) : "";

        selects.deliveryType.value = ability.deliverySpec?.type ?? "";
        document.getElementById("delivery-range").value = ability.deliverySpec?.range ?? "";
        document.getElementById("delivery-radius").value = ability.deliverySpec?.radius ?? "";
        selects.centerRef.value = ability.deliverySpec?.centerRef ?? "";
        document.getElementById("projectile-speed").value = ability.deliverySpec?.projectileSpeed ?? "";
        document.getElementById("max-distance").value = ability.deliverySpec?.maxDistance ?? "";
        selects.collisionRule.value = ability.deliverySpec?.collisionRule ?? "";
        document.getElementById("duration").value = ability.deliverySpec?.duration ?? "";
        document.getElementById("tick-interval").value = ability.deliverySpec?.tickInterval ?? "";

        refreshPreview();
        setStatus(`'${ability.abilityId}' 로드됨. 필요 필드를 수정한 뒤 저장하세요.`);
      }

      function resetForm() {
        document.querySelectorAll("input[type='text'], input[type='number'], textarea").forEach((input) => {
          input.value = "";
        });
        selects.slot.value = slotOptions[0];
        selects.deliveryType.value = "";
        selects.centerRef.value = "";
        selects.collisionRule.value = "";
        setStatus("새 Ability 입력을 시작하세요.");
        refreshPreview();
      }

      function renderTable(rows) {
        abilityTableBody.innerHTML = "";
        if (!rows.length) {
          const tr = document.createElement("tr");
          const td = document.createElement("td");
          td.colSpan = 6;
          td.textContent = "저장된 Ability가 없습니다.";
          tr.appendChild(td);
          abilityTableBody.appendChild(tr);
          return;
        }

        rows.forEach((row) => {
          const tr = document.createElement("tr");
          const summaryCells = [
            row.abilityId,
            row.slot,
            row.rankRules?.maxRank,
            row.effects?.map((e) => e.effectId).filter(Boolean).join(", "),
            row.deliverySpec?.type ?? "-",
          ];

          summaryCells.forEach((value) => {
            const td = document.createElement("td");
            td.textContent = value ?? "-";
            tr.appendChild(td);
          });

          const actionsTd = document.createElement("td");
          const loadBtn = document.createElement("button");
          loadBtn.className = "secondary";
          loadBtn.textContent = "불러오기";
          loadBtn.addEventListener("click", () => fillForm(row));

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "danger";
          deleteBtn.textContent = "삭제";
          deleteBtn.addEventListener("click", async () => {
            if (!confirm(`'${row.abilityId}'를 삭제할까요?`)) return;
            await deleteDoc(doc(abilitiesRef, row.id));
            setStatus(`'${row.abilityId}'를 삭제했습니다.`);
            loadAbilities();
            resetForm();
          });

          actionsTd.append(loadBtn, deleteBtn);
          tr.appendChild(actionsTd);
          abilityTableBody.appendChild(tr);
        });
      }

      async function loadAbilities() {
        setStatus("Ability 목록을 불러오는 중...");
        const snapshot = await getDocs(abilitiesRef);
        const rows = [];
        snapshot.forEach((docSnap) => {
          rows.push({ id: docSnap.id, ...docSnap.data() });
        });
        renderTable(rows);
        setStatus(`총 ${rows.length}개 Ability를 불러왔습니다.`);
      }

      async function saveAbility() {
        const ability = assembleAbility();
        if (!ability) return;
        const docId = ability.abilityId.replace(/\s+/g, "_").toLowerCase();
        await setDoc(doc(abilitiesRef, docId), ability, { merge: true });
        setStatus(`'${ability.abilityId}'가 저장되었습니다.`);
        loadAbilities();
        refreshPreview();
      }

      function attachPreviewListeners() {
        const elements = Array.from(document.querySelectorAll("input, select, textarea"));
        elements.forEach((el) => {
          const eventName = el.tagName === "SELECT" ? "change" : "input";
          el.addEventListener(eventName, refreshPreview);
        });
      }

      function applyPreset(label) {
        const preset = abilityPresets.find((p) => p.label === label);
        if (!preset) return;
        fillForm(structuredClone(preset.ability));
        refreshPreview();
        setStatus(`프리셋 '${preset.label}'을 불러왔습니다.`);
      }

      applyPresetBtn.addEventListener("click", () => applyPreset(presetSelect.value));

      saveBtn.addEventListener("click", async () => {
        saveBtn.disabled = true;
        try {
          await saveAbility();
        } catch (error) {
          console.error(error);
          setStatus("저장 중 오류가 발생했습니다. 콘솔을 확인하세요.");
        } finally {
          saveBtn.disabled = false;
        }
      });

      resetBtn.addEventListener("click", resetForm);

      renderStepIndicator();
      showStep(0);
      attachPreviewListeners();
      resetForm();
      loadAbilities().catch((error) => {
        console.error(error);
        setStatus("Ability를 불러오는 중 오류가 발생했습니다. 콘솔을 확인하세요.");
      });
    </script>
  </body>
</html>
