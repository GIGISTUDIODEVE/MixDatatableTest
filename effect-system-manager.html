<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Effect 관리 · EffectSystem.md 기반 생성/수정/삭제</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      background: #0f172a;
      color: #e2e8f0;
    }

    .top-nav {
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.9rem 1.5rem;
      margin: -1.5rem -1.5rem 1.25rem;
      background: rgba(11, 18, 32, 0.8);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid #1f2937;
    }

    .nav-brand {
      font-weight: 800;
      letter-spacing: -0.01em;
    }

    .nav-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .nav-link {
      color: #cbd5e1;
      text-decoration: none;
      padding: 0.45rem 0.8rem;
      border-radius: 10px;
      border: 1px solid transparent;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .nav-link:hover {
      background: #111827;
      border-color: #1f2937;
      color: #e2e8f0;
    }

    .nav-link.active {
      background: linear-gradient(90deg, #8b5cf6, #06b6d4);
      color: #0b1220;
      border-color: transparent;
    }

    h1 {
      margin-top: 0;
    }

    .container {
      display: grid;
      gap: 1.5rem;
    }

    .card {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .card h2 {
      margin-top: 0;
      margin-bottom: 0.35rem;
    }

    .muted {
      color: #94a3b8;
      font-size: 0.95rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.75rem 1rem;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 0.5rem 0.6rem;
      border-radius: 10px;
      border: 1px solid #334155;
      background: #0b1220;
      color: #e2e8f0;
      resize: vertical;
      min-height: 42px;
    }

    textarea {
      min-height: 70px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 9999px;
      background: #1f2937;
      border: 1px solid #334155;
      font-size: 0.92rem;
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 0.65rem 1.05rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, filter 0.15s ease;
    }

    button.primary {
      background: linear-gradient(90deg, #3b82f6, #06b6d4);
      color: #0b1220;
    }

    button.secondary {
      background: #1f2937;
      color: #e2e8f0;
      border: 1px solid #334155;
    }

    button.danger {
      background: #ef4444;
      color: #0b1220;
    }

    button:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
    }

    .stepper {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.75rem;
    }

    .step {
      padding: 0.75rem;
      border-radius: 12px;
      border: 1px solid #1f2937;
      background: #0b1220;
      display: grid;
      gap: 0.35rem;
    }

    .step.active {
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.4);
    }

    .step-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 800;
    }

    .helper {
      color: #cbd5e1;
      font-size: 0.93rem;
      line-height: 1.35;
    }

    .status {
      margin-top: 0.75rem;
      padding: 0.6rem 0.8rem;
      border-radius: 10px;
      background: #0b1220;
      border: 1px solid #1f2937;
      color: #cbd5e1;
      min-height: 1.4rem;
      white-space: pre-line;
    }

    .two-col {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 1rem;
    }

    .preview {
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 0.75rem;
      height: 100%;
    }

    pre {
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      color: #e2e8f0;
      font-size: 0.9rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }

    th, td {
      border-bottom: 1px solid #1f2937;
      padding: 0.6rem;
      text-align: left;
    }

    th {
      color: #cbd5e1;
      font-size: 0.95rem;
    }

    tr:hover td {
      background: #0b1220;
    }

    .badge {
      display: inline-block;
      padding: 0.2rem 0.55rem;
      border-radius: 9999px;
      background: #1f2937;
      border: 1px solid #334155;
      font-size: 0.82rem;
      color: #cbd5e1;
    }

    @media (max-width: 1024px) {
      .two-col {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <nav class="top-nav">
    <div class="nav-brand">Effect 관리 도구</div>
    <div class="nav-links">
      <a class="nav-link" href="base-stats-firestore.html">BaseStat 프리셋</a>
      <a class="nav-link" href="growth-base-stats-firestore.html">GrowthBaseStat 프리셋</a>
      <a class="nav-link" href="combat-stats-firestore.html">CombatStats 관리</a>
      <a class="nav-link active" href="effect-system-manager.html">Effect 관리</a>
    </div>
  </nav>

  <div class="container">
    <header class="card">
      <h1>Effect 관리 & 생성 플로우</h1>
      <p class="muted">
        EffectSystem.md의 공통 골격을 따라 Effect를 추가, 수정, 삭제할 수 있는 가이드형 페이지입니다. 트리거/타게팅/계산/적용/스택·프로크 세트를 단계별로 선택하고, 각 선택이 어떤 의미인지 바로 확인하세요.
      </p>
    </header>

    <section class="card">
      <h2>생성 플로우(앞선 선택 기반 UI)</h2>
      <p class="muted">
        아래 단계는 EffectSystem의 필수 블록을 순서대로 입력하도록 안내합니다. 앞서 고른 <strong>Effect 타입</strong>과 <strong>타게팅</strong>에 따라 필요한 UI만 노출되며,
        각 필드의 역할을 예시와 함께 설명합니다.
      </p>
      <div class="stepper" id="stepper"></div>
    </section>

    <section class="card two-col">
      <div>
        <div id="step-contents"></div>
        <div class="actions">
          <button class="secondary" id="prev-btn">이전 단계</button>
          <button class="primary" id="next-btn">다음 단계</button>
          <button class="primary" id="save-btn">Effect 저장/업데이트</button>
          <button class="secondary" id="reset-btn">입력 초기화</button>
        </div>
        <div class="status" id="status"></div>
      </div>
      <aside class="preview">
        <h3 style="margin-top:0">실시간 미리보기</h3>
        <p class="muted">툴팁/디버그용으로 직렬화된 EffectSpec입니다.</p>
        <pre id="preview"></pre>
        <div id="contextual-guide" class="helper" style="margin-top:0.75rem"></div>
      </aside>
    </section>

    <section class="card">
      <h2>저장된 Effect 목록 (로컬 보관)</h2>
      <p class="muted">브라우저 LocalStorage에 effectId 키 기준으로 저장합니다. 프로젝트 저장소에 영향이 없으니 자유롭게 실험하세요.</p>
      <table id="effect-table">
        <thead>
          <tr>
            <th>effectId</th>
            <th>타입</th>
            <th>트리거</th>
            <th>타게팅</th>
            <th>적용 모드</th>
            <th>작업</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <script type="module">
    const LOCAL_KEY = "effect-system-manager:effects";
    const effectTypes = {
      damage: ["Damage", "DamagePercentHP", "ExecuteDamage", "DamageOverTime"],
      status: ["ApplyStatus", "RemoveStatus", "DispelShield", "Interrupt"],
      heal: ["Heal", "HealOverTime", "Shield", "GrantLifesteal"],
      mobility: ["Dash", "Blink", "Knockback", "Knockup", "Pull", "SwapPosition"],
      zone: ["SpawnObject", "CreateZone", "ModifyZone", "Trap"],
      stat: ["ModifyStat", "ApplyMultiplier", "StealStat"],
      resource: ["GainResource", "SpendResource", "AddStack", "ConsumeStack", "ResetCooldown", "ReduceCooldown", "RefundCost"],
      control: ["Sequence", "Parallel", "Repeat", "RandomPick", "Conditional", "ScaleBy", "Link"],
      info: ["Reveal", "Nearsight", "MarkTarget"],
    };

    const triggerTypes = [
      "OnCastStart",
      "OnCastCommit",
      "OnCastEnd",
      "OnProjectileSpawn",
      "OnProjectileHit",
      "OnHit",
      "OnDamageDealt",
      "OnDamageTaken",
      "OnTick",
      "OnEnterZone",
      "OnExitZone",
      "WhileInZone",
      "OnBuffApplied",
      "OnBuffExpired",
      "AfterDelay",
      "OnKill",
      "OnAssist",
      "OnUnitDied",
    ];

    const selectorTypes = [
      "Self",
      "Caster",
      "HitTarget",
      "SelectedTarget",
      "Area",
      "Cone",
      "Line",
      "Chain",
      "NearestN",
      "LowestHP",
      "HighestMaxHP",
      "PriorityByTag",
    ];

    const steps = [
      { id: "identity", title: "1) 효과 ID/타입", helper: "effectId는 디버깅·툴팁 키입니다. type은 EffectType 카탈로그를 선택하세요." },
      { id: "triggerTarget", title: "2) 트리거 & 타게팅", helper: "언제/누구에게 적용되는지 결정합니다. 트리거 필터는 불필요하면 비워둡니다." },
      { id: "conditionTiming", title: "3) 조건 & 타이밍", helper: "확률·ICD·스택 조건과 딜레이/지속/틱 간격을 정의합니다." },
      { id: "calcApply", title: "4) 계산 & 적용", helper: "수치 모델과 적용 방식을 정합니다. Damage 타입은 데미지 타입을, Status 타입은 고유 그룹을 입력하세요." },
      { id: "stackProcEmit", title: "5) 중첩/프로크/이벤트", helper: "중첩 룰, 프로크 제한, 이벤트 페이로드를 마무리합니다." },
    ];

    const state = {
      effectId: "",
      type: "",
      enabled: true,
      tags: [],
      trigger: { triggerType: "OnHit", sourceFilter: "Ability" },
      targeting: { selectorType: "HitTarget", teamFilter: "Enemy", unitFilter: "Champion", maxTargets: 1 },
      conditions: [],
      timing: { delay: 0, duration: 0, tickInterval: 0 },
      calc: { model: "Flat", flat: 0, damageType: "Physical" },
      apply: { applicationMode: "Instant", canMiss: false, collisionRule: "FirstHit" },
      stacking: { stackingRule: "Unique", maxStacks: 1, uniqueGroup: "" },
      procRules: { internalCooldown: 0, procCoefficient: 1, oncePerCast: false, oncePerTarget: false },
      emit: { emitOnApply: true, emitOnHit: false, emitOnKill: false, payloadKeys: [] },
    };

    let currentStep = 0;
    const statusEl = document.getElementById("status");
    const previewEl = document.getElementById("preview");
    const guideEl = document.getElementById("contextual-guide");

    function createOption(value) {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = value;
      return option;
    }

    function buildSteps() {
      const stepper = document.getElementById("stepper");
      steps.forEach((step, index) => {
        const div = document.createElement("div");
        div.className = "step";
        div.dataset.stepIndex = String(index);
        const title = document.createElement("div");
        title.className = "step-title";
        title.innerHTML = `<span class="badge">${step.title}</span>`;
        const helper = document.createElement("div");
        helper.className = "helper";
        helper.textContent = step.helper;
        div.append(title, helper);
        div.addEventListener("click", () => goToStep(index));
        stepper.appendChild(div);
      });
      updateStepper();
    }

    function renderStepContents() {
      const container = document.getElementById("step-contents");
      container.innerHTML = "";
      container.append(
        renderIdentityStep(),
        renderTriggerTargetStep(),
        renderConditionTimingStep(),
        renderCalcApplyStep(),
        renderStackProcEmitStep(),
      );
      showOnlyCurrentStep();
    }

    function renderIdentityStep() {
      const section = document.createElement("section");
      section.dataset.stepId = "identity";
      section.className = "card";
      section.style.padding = "1rem";

      const grid = document.createElement("div");
      grid.className = "grid";

      const idField = labeledInput("effectId", "Effect ID (유니크)", "text", "Q_HitDamage");
      const typeSelect = labeledSelect("type", "Effect 타입", Object.values(effectTypes).flat());
      const enabledField = labeledCheckbox("enabled", "활성화(enabled)", true);
      const tagsField = labeledInput("tags", "태그 (쉼표 구분)", "text", "Spell, SingleTarget");

      const helper = document.createElement("div");
      helper.className = "helper";
      helper.innerHTML = `
        <div class="pill">역할</div>
        <ul style="margin:0.4rem 0 0.2rem 1rem; padding-left:1rem; color:#cbd5e1;">
          <li><strong>effectId</strong>: 디버깅·툴팁 키. 예) Q_Root.</li>
          <li><strong>type</strong>: 실행 로직 선택. Damage이면 계산·적용 옵션이 노출됩니다.</li>
          <li><strong>tags</strong>: Spell/Basic/AoE 등 상호작용 제어에 사용.</li>
        </ul>
      `;

      grid.append(idField, typeSelect, enabledField, tagsField);
      section.append(grid, helper);
      return section;
    }

    function renderTriggerTargetStep() {
      const section = document.createElement("section");
      section.dataset.stepId = "triggerTarget";
      section.className = "card";
      section.style.padding = "1rem";

      const grid = document.createElement("div");
      grid.className = "grid";

      const triggerType = labeledSelect("triggerType", "trigger.triggerType", triggerTypes);
      const sourceFilter = labeledSelect("sourceFilter", "trigger.sourceFilter", ["Ability", "BasicAttack", "Item", "Rune", "Modifier", "Any"]);
      const damageFilter = labeledSelect("damageTypeFilter", "trigger.damageTypeFilter", ["Any", "Physical", "Magic", "True"]);
      const selectorType = labeledSelect("selectorType", "targeting.selectorType", selectorTypes);
      const teamFilter = labeledSelect("teamFilter", "teamFilter", ["Enemy", "Ally", "Both"]);
      const unitFilter = labeledInput("unitFilter", "unitFilter (쉼표 구분)", "text", "Champion,Minion,Monster");
      const maxTargets = labeledInput("maxTargets", "maxTargets", "number", "1");
      const sortRule = labeledSelect("sortRule", "정렬 규칙", ["None", "Nearest", "LowestHP", "HighestMaxHP", "Custom"]);

      const helper = document.createElement("div");
      helper.className = "helper";
      helper.innerHTML = `
        <div class="pill">UI 안내</div>
        <ul style="margin:0.4rem 0 0.2rem 1rem; padding-left:1rem; color:#cbd5e1;">
          <li><strong>Trigger</strong>: OnHit 선택 시 투사체/기본 공격 모두 발동. OnTick 선택 시 타이밍에서 tickInterval만 노출됩니다.</li>
          <li><strong>Targeting</strong>: selectorType이 <em>Area/Cone/Line</em>이면 관련 파라미터 입력란이 자동 표시됩니다.</li>
          <li><strong>teamFilter/unitFilter</strong>: 적용 대상 그룹을 제한하여 의도치 않은 상호작용을 방지합니다.</li>
        </ul>
      `;

      grid.append(triggerType, sourceFilter, damageFilter, selectorType, teamFilter, unitFilter, maxTargets, sortRule, renderShapeOptions());
      section.append(grid, helper);
      return section;
    }

    function renderShapeOptions() {
      const wrapper = document.createElement("div");
      wrapper.id = "shape-options";
      wrapper.style.gridColumn = "1 / -1";
      wrapper.style.display = "none";

      const grid = document.createElement("div");
      grid.className = "grid";
      grid.style.gridTemplateColumns = "repeat(auto-fit, minmax(180px, 1fr))";

      const centerRef = labeledSelect("centerRef", "centerRef", ["CasterPos", "TargetPos", "ImpactPos", "CursorPos", "ZoneCenter"]);
      const radius = labeledInput("radius", "radius (Area)", "number", "350");
      const angle = labeledInput("angle", "angle (Cone)", "number", "45");
      const range = labeledInput("range", "range (Cone)", "number", "700");
      const width = labeledInput("width", "width (Line)", "number", "120");
      const length = labeledInput("length", "length (Line)", "number", "900");
      const bounces = labeledInput("bounces", "bounces (Chain)", "number", "3");
      const searchRadius = labeledInput("searchRadius", "searchRadius (Chain)", "number", "450");

      grid.append(centerRef, radius, angle, range, width, length, bounces, searchRadius);
      wrapper.append(grid);
      return wrapper;
    }

    function renderConditionTimingStep() {
      const section = document.createElement("section");
      section.dataset.stepId = "conditionTiming";
      section.className = "card";
      section.style.padding = "1rem";

      const grid = document.createElement("div");
      grid.className = "grid";

      const conditions = labeledInput("conditions", "conditions (한 줄당 ConditionType:상세)", "text", "OnceRules:oncePerCast, Chance:0.3");
      const delay = labeledInput("delay", "timing.delay (초)", "number", "0");
      const duration = labeledInput("duration", "timing.duration (초)", "number", "0");
      const tickInterval = labeledInput("tickInterval", "timing.tickInterval (초)", "number", "0");
      const snapshotPolicy = labeledSelect("snapshotPolicy", "snapshotPolicy", ["SnapshotOnCommit", "RecalcEveryTick"]);
      const cancelPolicy = labeledSelect("cancelPolicy", "cancelPolicy", ["NotCancelable", "CancelableNoRefund", "CancelableRefundCost", "InterruptedStop"]);

      const helper = document.createElement("div");
      helper.className = "helper";
      helper.innerHTML = `
        <div class="pill">조건 설명</div>
        <ul style="margin:0.4rem 0 0.2rem 1rem; padding-left:1rem; color:#cbd5e1;">
          <li><strong>OnceRules</strong>: oncePerCast=true면 한 번만 발동하여 중복 피해를 막습니다.</li>
          <li><strong>Chance</strong>: 0~1 확률. 예) 0.25면 25% 확률로 발동.</li>
          <li><strong>tickInterval</strong>: OnTick 트리거와 함께 DOT/ HOT 틱 간격을 정의합니다.</li>
        </ul>
      `;

      grid.append(conditions, delay, duration, tickInterval, snapshotPolicy, cancelPolicy);
      section.append(grid, helper);
      return section;
    }

    function renderCalcApplyStep() {
      const section = document.createElement("section");
      section.dataset.stepId = "calcApply";
      section.className = "card";
      section.style.padding = "1rem";

      const grid = document.createElement("div");
      grid.className = "grid";

      const model = labeledSelect("model", "calc.model", ["Flat", "FlatPlusRatio", "FlatByRank", "FlatByLevel", "Ratio", "PercentMaxHP", "PercentCurrentHP", "PercentMissingHP", "ByStacks", "ByTargetsHit", "ByTime", "Curve"]);
      const flat = labeledInput("flat", "calc.flat", "number", "80");
      const ratios = labeledInput("ratios", "calc.ratios (ap:0.6, ad:0.8)", "text", "ap:0.6,ad:0");
      const percent = labeledInput("percent", "calc.percent (%)", "number", "0");
      const damageType = labeledSelect("damageType", "damageType", ["Physical", "Magic", "True"]);
      const applicationMode = labeledSelect("applicationMode", "apply.applicationMode", ["Instant", "OverTime", "Aura", "Pulse", "OnExpireExplode"]);
      const canMiss = labeledSelect("canMiss", "hitRules.canMiss", ["false", "true"]);
      const collisionRule = labeledSelect("collisionRule", "hitRules.collisionRule", ["FirstHit", "Pierce", "StopOnUnit", "Reflectable"]);
      const uniqueGroup = labeledInput("uniqueGroup", "stacking.uniqueGroup (Status 타입 권장)", "text", "ROOT");

      const helper = document.createElement("div");
      helper.className = "helper";
      helper.innerHTML = `
        <div class="pill">필드 역할</div>
        <ul style="margin:0.4rem 0 0.2rem 1rem; padding-left:1rem; color:#cbd5e1;">
          <li><strong>FlatPlusRatio</strong>: 평타/스킬 계수 혼합. 예) flat=80, ap:0.6.</li>
          <li><strong>PercentMaxHP</strong>: 탱커 처치용. min/max를 추가해 폭주를 막습니다.</li>
          <li><strong>damageType</strong>: 피해 증폭·저항 계산에 필요.</li>
          <li><strong>uniqueGroup</strong>: CC 중복 방지. ROOT 그룹이면 한 개만 유지.</li>
        </ul>
      `;

      grid.append(model, flat, ratios, percent, damageType, applicationMode, canMiss, collisionRule, uniqueGroup);
      section.append(grid, helper);
      return section;
    }

    function renderStackProcEmitStep() {
      const section = document.createElement("section");
      section.dataset.stepId = "stackProcEmit";
      section.className = "card";
      section.style.padding = "1rem";

      const grid = document.createElement("div");
      grid.className = "grid";

      const stackingRule = labeledSelect("stackingRule", "stackingRule", ["RefreshDuration", "AddStacks", "Replace", "Unique"]);
      const maxStacks = labeledInput("maxStacks", "maxStacks", "number", "1");
      const internalCooldown = labeledInput("internalCooldown", "procRules.internalCooldown (초)", "number", "0");
      const procCoefficient = labeledInput("procCoefficient", "procRules.procCoefficient (0~1)", "number", "1");
      const oncePerCast = labeledSelect("oncePerCast", "procRules.oncePerCast", ["false", "true"]);
      const oncePerTarget = labeledSelect("oncePerTarget", "procRules.oncePerTarget", ["false", "true"]);
      const emitOnApply = labeledSelect("emitOnApply", "emit.emitOnApply", ["true", "false"]);
      const emitPayload = labeledInput("payloadKeys", "emit.payloadKeys (쉼표)", "text", "damageAmount,targets,sourceId");

      const helper = document.createElement("div");
      helper.className = "helper";
      helper.innerHTML = `
        <div class="pill">안정성 가이드</div>
        <ul style="margin:0.4rem 0 0.2rem 1rem; padding-left:1rem; color:#cbd5e1;">
          <li><strong>internalCooldown</strong>: 초 단위 내부 쿨타임. 0이면 완전 자유 프로크.</li>
          <li><strong>procCoefficient</strong>: 0~1 스케일. 0.5면 생명력 흡수/주문 흡혈 절반만 반영.</li>
          <li><strong>payloadKeys</strong>: 이벤트 버스에 전달할 페이로드. 예) damageAmount, statusId.</li>
        </ul>
      `;

      grid.append(stackingRule, maxStacks, internalCooldown, procCoefficient, oncePerCast, oncePerTarget, emitOnApply, emitPayload);
      section.append(grid, helper);
      return section;
    }

    function labeledInput(id, label, type, placeholder = "") {
      const wrapper = document.createElement("div");
      const labelEl = document.createElement("label");
      labelEl.htmlFor = id;
      labelEl.textContent = label;
      const input = document.createElement("input");
      input.type = type;
      input.id = id;
      input.placeholder = placeholder;
      wrapper.append(labelEl, input);
      return wrapper;
    }

    function labeledSelect(id, label, options) {
      const wrapper = document.createElement("div");
      const labelEl = document.createElement("label");
      labelEl.htmlFor = id;
      labelEl.textContent = label;
      const select = document.createElement("select");
      select.id = id;
      options.forEach((opt) => select.appendChild(createOption(opt)));
      wrapper.append(labelEl, select);
      return wrapper;
    }

    function labeledCheckbox(id, label, checked = false) {
      const wrapper = document.createElement("div");
      const labelEl = document.createElement("label");
      labelEl.htmlFor = id;
      labelEl.textContent = label;
      const input = document.createElement("input");
      input.type = "checkbox";
      input.id = id;
      input.checked = checked;
      wrapper.append(labelEl, input);
      return wrapper;
    }

    function goToStep(index) {
      currentStep = Math.max(0, Math.min(index, steps.length - 1));
      showOnlyCurrentStep();
      updateStepper();
      updateGuide();
    }

    function showOnlyCurrentStep() {
      const sections = document.querySelectorAll("[data-step-id]");
      sections.forEach((section, index) => {
        section.style.display = index === currentStep ? "block" : "none";
      });
      document.getElementById("prev-btn").disabled = currentStep === 0;
      document.getElementById("next-btn").disabled = currentStep === steps.length - 1;
    }

    function updateStepper() {
      document.querySelectorAll(".step").forEach((el, idx) => {
        el.classList.toggle("active", idx === currentStep);
      });
    }

    function parseList(value) {
      return value
        .split(/[,\\n]/)
        .map((v) => v.trim())
        .filter(Boolean);
    }

    function parseNumber(value) {
      const parsed = Number(value);
      return Number.isNaN(parsed) ? 0 : parsed;
    }

    function buildPayload() {
      const effectId = getValue("effectId");
      const type = getValue("type");
      const tags = parseList(getValue("tags"));

      const selectorType = getValue("selectorType");
      const targeting = {
        selectorType,
        teamFilter: getValue("teamFilter"),
        unitFilter: parseList(getValue("unitFilter")),
        maxTargets: parseNumber(getValue("maxTargets")),
        sortRule: getValue("sortRule"),
      };

      if (["Area", "Cone", "Line", "Chain"].includes(selectorType)) {
        targeting.centerRef = getValue("centerRef");
        targeting.radius = parseNumber(getValue("radius"));
        targeting.angle = parseNumber(getValue("angle"));
        targeting.range = parseNumber(getValue("range"));
        targeting.width = parseNumber(getValue("width"));
        targeting.length = parseNumber(getValue("length"));
        targeting.bounces = parseNumber(getValue("bounces"));
        targeting.searchRadius = parseNumber(getValue("searchRadius"));
      }

      const payload = {
        effectId,
        type,
        enabled: document.getElementById("enabled").checked,
        tags,
        trigger: {
          triggerType: getValue("triggerType"),
          sourceFilter: getValue("sourceFilter"),
          damageTypeFilter: getValue("damageTypeFilter"),
        },
        targeting,
        conditions: parseList(getValue("conditions")).map((entry) => {
          const [condType, detail] = entry.split(":").map((v) => v?.trim());
          return condType ? { type: condType, params: detail || "" } : null;
        }).filter(Boolean),
        timing: {
          delay: parseNumber(getValue("delay")),
          duration: parseNumber(getValue("duration")),
          tickInterval: parseNumber(getValue("tickInterval")),
          snapshotPolicy: getValue("snapshotPolicy"),
          cancelPolicy: getValue("cancelPolicy"),
        },
        calc: {
          model: getValue("model"),
          flat: parseNumber(getValue("flat")),
          ratios: parseRatio(getValue("ratios")),
          percent: parseNumber(getValue("percent")),
          damageType: getValue("damageType"),
        },
        apply: {
          applicationMode: getValue("applicationMode"),
          hitRules: {
            canMiss: getValue("canMiss") === "true",
            collisionRule: getValue("collisionRule"),
          },
        },
        stacking: {
          stackingRule: getValue("stackingRule"),
          maxStacks: parseNumber(getValue("maxStacks")),
          uniqueGroup: getValue("uniqueGroup"),
        },
        procRules: {
          internalCooldown: parseNumber(getValue("internalCooldown")),
          procCoefficient: parseNumber(getValue("procCoefficient")),
          oncePerCast: getValue("oncePerCast") === "true",
          oncePerTarget: getValue("oncePerTarget") === "true",
        },
        emit: {
          emitOnApply: getValue("emitOnApply") === "true",
          payloadKeys: parseList(getValue("payloadKeys")),
        },
      };

      return payload;
    }

    function parseRatio(value) {
      const result = {};
      parseList(value).forEach((pair) => {
        const [key, val] = pair.split(":").map((v) => v.trim());
        if (key) result[key] = parseNumber(val);
      });
      return result;
    }

    function getValue(id) {
      return document.getElementById(id)?.value?.trim() ?? "";
    }

    function updatePreview() {
      const payload = buildPayload();
      previewEl.textContent = JSON.stringify(payload, null, 2);
      updateGuide();
    }

    function updateGuide() {
      const type = getValue("type");
      const trigger = getValue("triggerType");
      const selector = getValue("selectorType");

      const guideLines = [
        `• type=${type} → ${guideType(type)}`,
        `• trigger=${trigger} → 발동 시점에만 실행되어 불필요한 호출을 줄입니다.`,
        `• targeting=${selector} → 입력한 shape 파라미터만 노출되어 설계자가 필요한 값만 입력하게 합니다.`,
      ];

      guideEl.textContent = guideLines.join("\\n");
    }

    function guideType(type) {
      if (effectTypes.damage.includes(type)) return "데미지 계열로 damageType/rations 필드가 중요합니다.";
      if (effectTypes.status.includes(type)) return "상태이상 계열로 stacking.uniqueGroup으로 중복 적용을 제어하세요.";
      if (effectTypes.heal.includes(type)) return "회복/보호 계열로 snapshot 정책을 신중히 선택합니다.";
      if (effectTypes.control.includes(type)) return "컨트롤 플로우용으로 링크·반복 로직만 구성합니다.";
      return "선택한 타입에 맞춰 필요한 값만 입력합니다.";
    }

    function onTypeChange() {
      const type = getValue("type");
      const damageNeeded = effectTypes.damage.includes(type);
      const statusNeeded = effectTypes.status.includes(type);
      toggleRow("damageType", damageNeeded);
      toggleRow("uniqueGroup", statusNeeded);
    }

    function onSelectorChange() {
      const selectorType = getValue("selectorType");
      const showShape = ["Area", "Cone", "Line", "Chain"].includes(selectorType);
      document.getElementById("shape-options").style.display = showShape ? "block" : "none";
    }

    function toggleRow(id, show) {
      const el = document.getElementById(id)?.closest("div");
      if (el) el.style.display = show ? "block" : "none";
    }

    function saveEffect() {
      const payload = buildPayload();
      if (!payload.effectId) {
        setStatus("effectId를 입력하세요.");
        return;
      }
      const effects = loadEffects();
      effects[payload.effectId] = payload;
      localStorage.setItem(LOCAL_KEY, JSON.stringify(effects));
      renderTable();
      setStatus(`'${payload.effectId}' Effect가 저장되었습니다.`);
    }

    function loadEffects() {
      try {
        return JSON.parse(localStorage.getItem(LOCAL_KEY) ?? "{}");
      } catch (error) {
        console.error(error);
        return {};
      }
    }

    function renderTable() {
      const tbody = document.querySelector("#effect-table tbody");
      tbody.innerHTML = "";
      const effects = loadEffects();
      const ids = Object.keys(effects);
      if (!ids.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 6;
        td.textContent = "저장된 Effect가 없습니다.";
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      ids.forEach((id) => {
        const effect = effects[id];
        const tr = document.createElement("tr");
        const cells = [
          effect.effectId,
          effect.type,
          effect.trigger?.triggerType,
          effect.targeting?.selectorType,
          effect.apply?.applicationMode,
        ];

        cells.forEach((value) => {
          const td = document.createElement("td");
          td.textContent = value ?? "-";
          tr.appendChild(td);
        });

        const actionsTd = document.createElement("td");
        const loadBtn = document.createElement("button");
        loadBtn.className = "secondary";
        loadBtn.textContent = "불러오기";
        loadBtn.addEventListener("click", () => fillForm(effect));

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "danger";
        deleteBtn.textContent = "삭제";
        deleteBtn.addEventListener("click", () => deleteEffect(effect.effectId));

        actionsTd.append(loadBtn, deleteBtn);
        tr.appendChild(actionsTd);
        tbody.appendChild(tr);
      });
    }

    function fillForm(effect) {
      setValue("effectId", effect.effectId);
      setValue("type", effect.type);
      document.getElementById("enabled").checked = Boolean(effect.enabled);
      setValue("tags", (effect.tags ?? []).join(", "));
      setValue("triggerType", effect.trigger?.triggerType);
      setValue("sourceFilter", effect.trigger?.sourceFilter);
      setValue("damageTypeFilter", effect.trigger?.damageTypeFilter ?? "Any");

      setValue("selectorType", effect.targeting?.selectorType);
      setValue("teamFilter", effect.targeting?.teamFilter);
      setValue("unitFilter", (effect.targeting?.unitFilter ?? []).join(","));
      setValue("maxTargets", effect.targeting?.maxTargets);
      setValue("sortRule", effect.targeting?.sortRule);
      setValue("centerRef", effect.targeting?.centerRef);
      setValue("radius", effect.targeting?.radius);
      setValue("angle", effect.targeting?.angle);
      setValue("range", effect.targeting?.range);
      setValue("width", effect.targeting?.width);
      setValue("length", effect.targeting?.length);
      setValue("bounces", effect.targeting?.bounces);
      setValue("searchRadius", effect.targeting?.searchRadius);

      setValue("conditions", (effect.conditions ?? []).map((c) => `${c.type}:${c.params ?? ""}`).join(", "));
      setValue("delay", effect.timing?.delay);
      setValue("duration", effect.timing?.duration);
      setValue("tickInterval", effect.timing?.tickInterval);
      setValue("snapshotPolicy", effect.timing?.snapshotPolicy);
      setValue("cancelPolicy", effect.timing?.cancelPolicy);

      setValue("model", effect.calc?.model);
      setValue("flat", effect.calc?.flat);
      setValue("ratios", stringifyRatio(effect.calc?.ratios));
      setValue("percent", effect.calc?.percent);
      setValue("damageType", effect.calc?.damageType);

      setValue("applicationMode", effect.apply?.applicationMode);
      setValue("canMiss", String(effect.apply?.hitRules?.canMiss ?? false));
      setValue("collisionRule", effect.apply?.hitRules?.collisionRule);
      setValue("uniqueGroup", effect.stacking?.uniqueGroup);
      setValue("stackingRule", effect.stacking?.stackingRule);
      setValue("maxStacks", effect.stacking?.maxStacks);

      setValue("internalCooldown", effect.procRules?.internalCooldown);
      setValue("procCoefficient", effect.procRules?.procCoefficient);
      setValue("oncePerCast", String(effect.procRules?.oncePerCast ?? false));
      setValue("oncePerTarget", String(effect.procRules?.oncePerTarget ?? false));

      setValue("emitOnApply", String(effect.emit?.emitOnApply ?? false));
      setValue("payloadKeys", (effect.emit?.payloadKeys ?? []).join(","));

      onTypeChange();
      onSelectorChange();
      updatePreview();
      setStatus(`'${effect.effectId}'를 편집 중입니다.`);
    }

    function stringifyRatio(ratios = {}) {
      return Object.entries(ratios)
        .map(([k, v]) => `${k}:${v}`)
        .join(", ");
    }

    function deleteEffect(effectId) {
      const effects = loadEffects();
      delete effects[effectId];
      localStorage.setItem(LOCAL_KEY, JSON.stringify(effects));
      renderTable();
      setStatus(`'${effectId}' Effect가 삭제되었습니다.`);
    }

    function setValue(id, value) {
      const el = document.getElementById(id);
      if (!el || value === undefined || value === null) return;
      el.value = String(value);
    }

    function resetForm() {
      document.querySelectorAll("input, select").forEach((el) => {
        if (el.type === "checkbox") {
          el.checked = el.id === "enabled";
        } else {
          el.value = "";
        }
      });
      document.getElementById("effectId").value = "Q_NewEffect";
      document.getElementById("type").value = "Damage";
      document.getElementById("triggerType").value = "OnHit";
      document.getElementById("sourceFilter").value = "Ability";
      document.getElementById("damageTypeFilter").value = "Any";
      document.getElementById("selectorType").value = "HitTarget";
      document.getElementById("teamFilter").value = "Enemy";
      document.getElementById("unitFilter").value = "Champion,Minion,Monster";
      document.getElementById("maxTargets").value = "1";
      document.getElementById("centerRef").value = "CasterPos";
      document.getElementById("radius").value = "350";
      document.getElementById("angle").value = "45";
      document.getElementById("range").value = "700";
      document.getElementById("width").value = "120";
      document.getElementById("length").value = "900";
      document.getElementById("bounces").value = "0";
      document.getElementById("searchRadius").value = "0";
      document.getElementById("snapshotPolicy").value = "SnapshotOnCommit";
      document.getElementById("cancelPolicy").value = "NotCancelable";
      document.getElementById("conditions").value = "OnceRules:oncePerCast";
      document.getElementById("delay").value = "0";
      document.getElementById("duration").value = "0";
      document.getElementById("tickInterval").value = "0";
      document.getElementById("model").value = "FlatPlusRatio";
      document.getElementById("flat").value = "80";
      document.getElementById("ratios").value = "ap:0.6";
      document.getElementById("percent").value = "0";
      document.getElementById("damageType").value = "Magic";
      document.getElementById("applicationMode").value = "Instant";
      document.getElementById("canMiss").value = "false";
      document.getElementById("collisionRule").value = "FirstHit";
      document.getElementById("stackingRule").value = "Unique";
      document.getElementById("maxStacks").value = "1";
      document.getElementById("uniqueGroup").value = "";
      document.getElementById("internalCooldown").value = "0";
      document.getElementById("procCoefficient").value = "1";
      document.getElementById("oncePerCast").value = "false";
      document.getElementById("oncePerTarget").value = "false";
      document.getElementById("emitOnApply").value = "true";
      document.getElementById("payloadKeys").value = "damageAmount,targets,sourceId";
      onTypeChange();
      onSelectorChange();
      goToStep(0);
      updatePreview();
      setStatus("새 Effect 입력을 시작합니다.");
    }

    function setStatus(message) {
      statusEl.textContent = message;
    }

    function attachListeners() {
      document.getElementById("next-btn").addEventListener("click", () => goToStep(currentStep + 1));
      document.getElementById("prev-btn").addEventListener("click", () => goToStep(currentStep - 1));
      document.getElementById("save-btn").addEventListener("click", () => {
        try {
          saveEffect();
        } catch (error) {
          console.error(error);
          setStatus("저장 중 오류가 발생했습니다. 입력값을 확인하세요.");
        } finally {
          updatePreview();
        }
      });
      document.getElementById("reset-btn").addEventListener("click", () => resetForm());

      ["type", "selectorType"].forEach((id) => {
        document.getElementById(id).addEventListener("change", () => {
          if (id === "type") onTypeChange();
          if (id === "selectorType") onSelectorChange();
          updatePreview();
        });
      });

      document.querySelectorAll("input, select, textarea").forEach((el) => {
        el.addEventListener("input", updatePreview);
        el.addEventListener("change", updatePreview);
      });
    }

    function init() {
      buildSteps();
      renderStepContents();
      attachListeners();
      resetForm();
      renderTable();
      updateGuide();
    }

    init();
  </script>
</body>
</html>
